use std::collections::HashMap;

struct Solution;

fn div_by(n: i32, d: i32) -> bool {
    n % d == 0
}

impl Solution {
    pub fn minimum_rounds(tasks: Vec<i32>) -> i32 {
        let hash_map = tasks.into_iter().fold(HashMap::new(), |mut acc, item| {
            let entry = acc.entry(item).or_insert(0);
            *entry += 1;

            acc
        });

        let mut sum = 0;
        for (_, counts) in hash_map.into_iter() {
            if counts == 1 {
                return -1;
            } else if div_by(counts, 3) {
                sum += counts / 3;
            } else {
                sum += counts / 3 + 1
            }
        }

        sum
    }
}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let scenarios = vec![
            (vec![2, 2, 3, 3, 2, 4, 4, 4, 4], 4),
            (vec![2, 3, 3], -1),
            (
                vec![
                    69, 65, 62, 64, 70, 68, 69, 67, 60, 65, 69, 62, 65, 65, 61, 66, 68, 61, 65, 63,
                    60, 66, 68, 66, 67, 65, 63, 65, 70, 69, 70, 62, 68, 70, 60, 68, 65, 61, 64, 65,
                    63, 62, 62, 62, 67, 62, 62, 61, 66, 69,
                ],
                20,
            ),
            (
                vec![
                    218, 211, 220, 218, 211, 218, 218, 217, 213, 215, 219, 214, 210, 210, 212, 219,
                    214, 211, 216, 218, 211, 216, 218, 218, 212, 210, 211, 211, 215, 216, 212, 219,
                    219, 210, 217, 218, 217, 217, 213, 216, 217, 212, 217, 219, 215, 217, 215, 218,
                    210, 218, 218, 210, 212, 219, 217, 214, 216, 218, 220, 217, 215, 215, 213, 210,
                    212, 211, 215, 218, 214, 212, 211, 216, 210, 216, 218, 220, 211, 211, 212, 218,
                    218, 210, 215, 210, 215, 213, 212, 220, 217, 219, 214, 216, 217, 214, 215, 213,
                    218, 219, 220, 219, 215, 216, 219, 218, 211, 215, 210, 214, 210, 215, 219, 214,
                    212, 217, 219, 215, 214, 217, 213, 219, 213, 218, 217, 214, 216, 219, 217, 217,
                    211, 214, 214, 220, 220, 216, 218, 216, 220, 211, 213, 219, 218, 219, 215, 216,
                    216, 220, 211, 214, 212, 219, 210, 215, 218, 218, 220, 210, 214, 211, 217, 214,
                    220, 214, 213, 210, 219, 213, 214, 210, 212, 216, 210, 217, 211, 215, 217, 213,
                    214, 210, 217, 212, 217, 216, 217, 210, 211, 213, 214, 220, 211, 216, 214, 211,
                    217, 211, 211, 215, 219, 219, 213, 216,
                ],
                70,
            ),
        ];

        scenarios
            .into_iter()
            .enumerate()
            .for_each(|(idx, (input, expected))| {
                let result = Solution::minimum_rounds(input);
                assert_eq!(result, expected);
                println!("  âœ“ scenario {}", idx + 1)
            });
    }
}
